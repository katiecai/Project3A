#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdint.h>
#include <time.h>
#include "ext2_fs.h"

#define BUFF_SIZE 2048
#define superblock_offset 1024

int ext2fd; //file descriptor for disk image
char buffer[BUFF_SIZE];
unsigned int block_size;
unsigned int inode_count;
int block_count;
int blocks_bitmap;
int inodes_bitmap;
int inode_table;
char justtime[20];

void superblock_summary(void)
{
  int toRead = sizeof(struct ext2_super_block);
  toRead = pread(ext2fd, buffer, toRead, superblock_offset);
  if (toRead < 0)
    {
      fprintf(stderr, "hello");
      //systemCallError
    }
  struct ext2_super_block* superblock_ptr;
  superblock_ptr = (struct ext2_super_block*) buffer;
  printf("SUPERBLOCK,");
  //block count
  printf("%d,", superblock_ptr->s_blocks_count);
  block_count = superblock_ptr->s_blocks_count;
  //inode count
  printf("%d,", superblock_ptr->s_inodes_count);
  inode_count = superblock_ptr->s_inodes_count;
  //block size
  printf("%d,", 1024 << superblock_ptr->s_log_block_size);
  block_size = 1024 << (superblock_ptr->s_log_block_size);
  //inode size
  printf("%d,", superblock_ptr->s_inode_size);
  //blocks per group
  printf("%d,", superblock_ptr->s_blocks_per_group);
  //inodes per group
  printf("%d,", superblock_ptr->s_inodes_per_group);
  //first non-reserved i-node
  printf("%d\n", superblock_ptr->s_first_ino);
}

void group_summary(void) 
{
  int toRead = sizeof(struct ext2_group_desc);
  toRead = pread(ext2fd, buffer, toRead, superblock_offset+sizeof(struct ext2_super_block));
  if (toRead < 0)
    {
      fprintf(stderr, "hello");
      // syscall error
    }
  struct ext2_group_desc* group_pointer = (struct ext2_group_desc*)buffer;
  printf("GROUP,");
  // group number
  printf("%d,", 0);
  // total number of blocks in the group
  printf("%d,", block_count);
  // total number of inodes in the group
  printf("%d,", inode_count);
  // total number of free blocks
  printf("%d,", group_pointer->bg_free_blocks_count);
  // total number of free inodes
  printf("%d,", group_pointer->bg_free_inodes_count);
  // block number of free block bitmap
  printf("%d,", group_pointer->bg_block_bitmap);
  blocks_bitmap = group_pointer->bg_block_bitmap;
  // block number of the free inode bitmap
  printf("%d,", group_pointer->bg_inode_bitmap);
  inodes_bitmap = group_pointer->bg_inode_bitmap;
  // block number of the inode table
  printf("%d\n", group_pointer->bg_inode_table);
  inode_table = group_pointer->bg_inode_table;
}

void free_blocks(void) 
{
  uint8_t* bitmap = malloc(block_size*sizeof(uint8_t));
  int toRead = pread(ext2fd, bitmap, block_size, blocks_bitmap*block_size);
  if (toRead < 0)
    {
      // syscall error
    }

  uint32_t i;
  uint32_t bitmap_size = block_count;
  int counter = 0;

  for (i = 0; i < bitmap_size; i++)
    {
      uint8_t a_byte = bitmap[i/8];
      if (!(a_byte & (1 << (i % 8))))
	{
	  counter++;
	  printf("BFREE,");
	  printf("%d\n", i);
	}
    }
  free(bitmap);
}

void free_inodes(void)
{
  uint8_t *bitmap = malloc(block_size);
  int toRead = pread(ext2fd, bitmap, block_size, block_size * (inodes_bitmap)); 
  if (toRead < 0)
    {
      fprintf(stderr, "Error!");
      // system call error function
    }
  uint32_t bitmap_size = inode_count;
  uint32_t bit_num;
  //first index of inode table is 1
  int inode_ctr = 1;
  int free_inodes = 0;


  for (bit_num = 0; bit_num < bitmap_size; bit_num++)
    {
      uint8_t a_byte = bitmap[bit_num / 8];
      if (!(a_byte & (1 << (bit_num % 8))))
	{
	  printf("IFREE, %d\n", inode_ctr);
	  free_inodes++;
	}
      inode_ctr++;
    }  
  free(bitmap);
}

void convert_time(uint32_t seconds, char* buffer) {
  time_t rawtime = (time_t)seconds;
  struct tm* info;

  time(&rawtime);
  info = gmtime(&rawtime);
  strftime(buffer, 20, "%X", info);
}

void inode_summary(void)
{  
  unsigned int i;
  char modified_buffer[20];
  char accessed_buffer[20];

  for (i = 0; i < inode_count; i++)
    {
      int toRead = sizeof(struct ext2_inode);
      toRead = pread(ext2fd, buffer, toRead, (block_size * inode_table + (i * toRead)));
      if (toRead < 0)
	{
	  fprintf(stderr, "hello");
	  //system call error
	}
      struct ext2_inode* inode_ptr = (struct ext2_inode*) buffer;

      if (inode_ptr->i_mode == 0 || inode_ptr->i_links_count == 0)
	continue;

      printf("INODE,");
      printf("%d,", i+1);
      int fileMode = inode_ptr->i_mode;
      
      if (fileMode & 0x4000)
	{
	  printf("d,");
	  //deal with directories
	}
      else if (fileMode & 0x8000)
	printf("f,");
      else if (fileMode & 0xA000)
	printf("s,");
      else
	printf("?,");
      printf("0%o,", fileMode);
      printf("%d,", inode_ptr->i_uid);
      printf("%d,", inode_ptr->i_gid);
      printf("%d,", inode_ptr->i_links_count);
      convert_time(inode_ptr->i_mtime, modified_buffer);
      printf("%s,", modified_buffer);
      convert_time(inode_ptr->i_atime, accessed_buffer);
      printf("%s,", accessed_buffer);
      printf("%d,", inode_ptr->i_size);
      printf("%d,", inode_ptr->i_blocks);
      printf("\n");
    }  
}

int main(int argc, char* argv[])
{
  if (argc != 2)
    {
      fprintf(stderr, "Wrong number of parameters!");
      exit(1);
    }

  ext2fd = open (argv[1], O_RDONLY);
  if (ext2fd < 0)
    {
      fprintf(stderr, "Error opening disk image!");
      exit(1);
    }
  superblock_summary();
  group_summary();
  free_blocks();
  free_inodes();
  inode_summary();
  return 0;
}
